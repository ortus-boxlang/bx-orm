package ortus.boxlang.modules.orm.mapping;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Element;

import ortus.boxlang.modules.orm.config.ORMKeys;
import ortus.boxlang.modules.orm.mapping.inspectors.IEntityMeta;
import ortus.boxlang.modules.orm.mapping.inspectors.IPropertyMeta;
import ortus.boxlang.runtime.dynamic.casters.StringCaster;
import ortus.boxlang.runtime.scopes.Key;
import ortus.boxlang.runtime.types.IStruct;
import ortus.boxlang.runtime.types.exceptions.BoxRuntimeException;

public class HibernateXMLWriter implements IPersistenceWriter {

	private static final Logger	logger	= LoggerFactory.getLogger( HibernateXMLWriter.class );

	/**
	 * IEntityMeta instance which represents the parsed entity metadata in a normalized form.
	 * <p>
	 * The source of this metadata could be CFML persistent
	 * annotations like `persistent=true` and `fieldtype="id"` OR modern BoxLang-syntax, JPA-style annotations like `@Entity` and `@Id`.
	 */
	IEntityMeta					entity;

	/**
	 * XML Document root, created by the constructor.
	 * <p>
	 * This is the root element of the Hibernate mapping document, and will be returned by {@link #generateXML()}.
	 */
	Document					document;

	public HibernateXMLWriter( IEntityMeta entity ) {
		this.entity		= entity;
		this.document	= createDocument();
	}

	public Document createDocument() {
		DocumentBuilderFactory	factory	= DocumentBuilderFactory.newInstance();
		DocumentBuilder			builder;
		try {
			builder = factory.newDocumentBuilder();

			DocumentType	doctype			= builder.getDOMImplementation().createDocumentType( "doctype", "-//Hibernate/Hibernate Mapping DTD 3.0//EN",
			    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd" );
			Document		rootDocument	= builder.getDOMImplementation().createDocument( null, "hibernate-mapping", doctype );
			rootDocument.insertBefore( rootDocument.createComment(
			    """
			    \n~ Generated by the Ortus BoxLang ORM module for use in BoxLang web applications.
			    ~
			    ~ https://github.com/ortus-boxlang/bx-orm
			    ~ https://boxlang.io
			    ~ https://docs.jboss.org/hibernate/orm/5.0/manual/en-US/html/ch05.html
			    """
			), rootDocument.getDocumentElement() );
			return rootDocument;
		} catch ( ParserConfigurationException e ) {
			// @TODO: Check ORMConfig.skipCFCWithError and throw if false.
			e.printStackTrace();
			logger.error( "Error creating Hibernate XML document: {}", e.getMessage(), e );
			throw new BoxRuntimeException( "Error creating Hibernate XML document: " + e.getMessage(), e );
		}
	}

	@Override
	public Document generateXML() {
		this.document.getDocumentElement().appendChild( generateClassElement() );
		return this.document;
	}

	/**
	 * Generate a &lt;property /&gt; element for the given property metadata.
	 * <p>
	 * Uses these annotations:
	 * <ul>
	 * <li>name</li>
	 * <li>type</li>
	 * <li>column</li>
	 * <li>unsavedValue</li>
	 * <li>and many, many more to come</li>
	 * </ul>
	 *
	 * @param prop Property metadata in struct form
	 *
	 * @return A &lt;property /&gt; element ready to add to a Hibernate mapping document
	 */
	public Element generatePropertyElement( IPropertyMeta prop ) {
		IStruct	column	= prop.getColumn();
		IStruct	types	= prop.getTypes();

		Element	theNode	= this.document.createElement( "property" );
		theNode.setAttribute( "name", prop.getName() );
		theNode.setAttribute( "type", types.getAsString( ORMKeys.ORMType ) );

		if ( prop.getFormula() != null ) {
			theNode.setAttribute( "formula", "(" + prop.getFormula() + ")" );
		} else {
			theNode.appendChild( generateColumnElement( prop ) );
		}
		// @TODO: generated
		if ( column.containsKey( ORMKeys.insertable ) ) {
			theNode.setAttribute( "insert", column.getAsString( ORMKeys.insertable ) );
		}
		if ( column.containsKey( ORMKeys.updateable ) ) {
			theNode.setAttribute( "update", column.getAsString( ORMKeys.updateable ) );
		}
		if ( prop.isLazy() ) {
			theNode.setAttribute( "lazy", "true" );
		}
		if ( !prop.isOptimisticLock() ) {
			theNode.setAttribute( "optimistic-lock", "false" );
		}

		/**
		 * TODO: Implement or test all the below:
		 * table
		 * catalog ** ACF only?
		 * schema ** ACF only?
		 * column
		 * formula
		 * persistent / transient
		 * where
		 * dbdefault
		 * sqltype
		 * cfc
		 * mappedBy
		 * optimisticlock
		 * insert
		 * update
		 * unique
		 * notnull
		 * uniqueKey
		 * constrained
		 * cascade
		 * fetch
		 * lazy
		 * orderby
		 * missingRowIgnored
		 * linktable
		 * linkcatalog
		 * linkschema
		 * joinColumn
		 * inverse
		 * inversejoincolumn
		 * structkeycolumn
		 * structkeytype
		 * structkeydatatype ?? ACF only?
		 * elementcolumn
		 * elementtype
		 * index
		 * ormType
		 * fieldtype
		 * unSavedValue - deprecated
		 *
		 * ## Generator annotations
		 * generated
		 * generator
		 * params
		 * sequence
		 * selectKey
		 */

		return theNode;
	}

	/**
	 * Generate a &lt;column /&gt; element for the given column metadata.
	 * <p>
	 * A column element can be used in a property, id, key, or other element to define column metadata.
	 *
	 * @TODO: Refactor all key logic into a getPropertyColumn() method which groups and combines all the various column-specific annotations.
	 *
	 * @param prop Column metadata
	 *
	 * @return A &lt;column /&gt; element ready to add to a Hibernate mapping document
	 */
	public Element generateColumnElement( IPropertyMeta prop ) {
		Element	columnNode	= this.document.createElement( "column" );
		IStruct	columnInfo	= prop.getColumn();
		IStruct	types		= prop.getTypes();

		columnNode.setAttribute( "name", prop.getName() );
		if ( columnInfo.containsKey( ORMKeys.nullable ) && Boolean.TRUE.equals( columnInfo.getAsBoolean( ORMKeys.nullable ) ) ) {
			columnNode.setAttribute( "not-null", "true" );
		}
		if ( columnInfo.containsKey( ORMKeys.unique ) && Boolean.TRUE.equals( columnInfo.getAsBoolean( ORMKeys.unique ) ) ) {
			columnNode.setAttribute( "unique", "true" );
		}
		if ( columnInfo.containsKey( ORMKeys.length ) ) {
			columnNode.setAttribute( "length", columnInfo.getAsString( ORMKeys.length ) );
		}
		if ( columnInfo.containsKey( ORMKeys.precision ) ) {
			columnNode.setAttribute( "precision", columnInfo.getAsString( ORMKeys.precision ) );
		}
		if ( columnInfo.containsKey( ORMKeys.scale ) ) {
			columnNode.setAttribute( "scale", columnInfo.getAsString( ORMKeys.scale ) );
		}
		// if ( prop.hasPropertyAnnotation( prop, ORMKeys.unsavedValue ) ) {
		// columnNode.setAttribute( "unsaved-value", prop.getPropertyAnnotation( prop, ORMKeys.unsavedValue ) );
		// }
		// if ( prop.hasPropertyAnnotation( prop, ORMKeys.check ) ) {
		// columnNode.setAttribute( "check", prop.getPropertyAnnotation( prop, ORMKeys.check ) );
		// }
		// if ( prop.hasPropertyAnnotation( prop, ORMKeys.dbDefault ) ) {
		// columnNode.setAttribute( "default", prop.getPropertyAnnotation( prop, ORMKeys.dbDefault ) );
		// }
		if ( types.containsKey( Key.sqltype ) ) {
			columnNode.setAttribute( "sql-type", types.getAsString( Key.sqltype ) );
		}
		// String uniqueKey = prop.getPropertyUniqueKey( prop );
		// if ( uniqueKey != null ) {
		// columnNode.setAttribute( "unique-key", uniqueKey );
		// }
		return columnNode;
	}

	/**
	 * Generate a &lt;id /&gt; element for the given property metadata.
	 * <p>
	 * Uses these annotations:
	 * <ul>
	 * <li>name</li>
	 * <li>type</li>
	 * <li>column</li>
	 * <li>unsavedValue</li>
	 * <li>access</li>
	 * <li>length</li>
	 * <li>and many, many more to come</li>
	 * </ul>
	 *
	 * @param prop Property metadata in struct form
	 *
	 * @return A &lt;id /&gt; element ready to add to a Hibernate mapping document
	 */
	public Element generateIdElement( IPropertyMeta prop ) {
		Element theNode = this.document.createElement( "id" );
		// if ( inspector.hasPropertyAnnotation( prop, ORMKeys.generator ) ) {
		// theNode.appendChild( generateGeneratorElement( prop ) );
		// // @TODO: Determine ID type from generator type IF a generator is specified.
		// }

		// compute defaults - move to ORMAnnotationInspector?
		// prop.getAsStruct( Key.annotations ).computeIfAbsent( ORMKeys.ORMType, ( key ) -> "string" );

		// set common attributes
		theNode.setAttribute( "name", prop.getName() );
		IStruct types = prop.getTypes();
		if ( types.containsKey( ORMKeys.ORMType ) ) {
			theNode.setAttribute( "type", types.getAsString( ORMKeys.ORMType ) );
		}
		if ( prop.getUnsavedValue() != null ) {
			theNode.setAttribute( "unsaved-value", prop.getUnsavedValue() );
		}

		theNode.appendChild( generateColumnElement( prop ) );

		return theNode;
	}

	/**
	 * Generate a &lt;discriminator&gt; element for the entity metadata.
	 * <p>
	 * Uses these annotations:
	 * <ul>
	 * <li>@discriminator</li>
	 * <li>@discriminatorColumn</li>
	 * <li>@discriminatorType</li>
	 * </ul>
	 * <p>
	 * The resulting XML might look something like this:
	 * <code>
	* <discriminator
	column="discriminator_column"
	type="discriminator_type"
	force="true|false"
	insert="true|false"
	formula="arbitrary sql expression"
	/>
	</code>
	 *
	 * @param classEl Parent &lt;class&gt; element to add the &lt;discriminator&gt; element to
	 * @param data    Discriminator metadata in struct form. If this is empty, no amendments will be made.
	 *
	 * @return nothing - document mutation is done in place
	 */
	public void addDiscriminatorData( Element classEl, IStruct data ) {
		if ( data.isEmpty() ) {
			return;
		}
		if ( data.containsKey( Key.value ) ) {
			classEl.setAttribute( "discriminator-value", data.getAsString( Key.value ) );
		}
		if ( data.containsKey( Key._name ) ) {
			Element theNode = this.document.createElement( "discriminator" );
			theNode.setAttribute( "column", data.getAsString( Key._name ) );

			// set conditional attributes
			if ( data.containsKey( Key.type ) ) {
				theNode.setAttribute( "type", data.getAsString( Key.type ) );
			}
			if ( data.containsKey( Key.force ) ) {
				theNode.setAttribute( "force", ( String ) data.get( Key.force ) );
			}
			if ( data.containsKey( ORMKeys.insert ) ) {
				theNode.setAttribute( "insert", ( String ) data.get( ORMKeys.insert ) );
			}
			if ( data.containsKey( ORMKeys.formula ) ) {
				theNode.setAttribute( "formula", ( String ) data.get( ORMKeys.formula ) );
			}
			classEl.appendChild( theNode );
		}
	}

	// /**
	// * Generate a &lt;generator/&gt; element for the given property metadata.
	// * <p>
	// * Uses these annotations:
	// * <ul>
	// * <li>generator</li>
	// * <li>params</li>
	// * <li>sequence</li>
	// * <li>selectKey</li>
	// * <li>generated</li>
	// * </ul>
	// *
	// * @param prop Property metadata in struct form
	// *
	// * @return A &lt;generator /&gt; element ready to add to a Hibernate mapping document
	// */
	// public Element generateGeneratorElement( IStruct prop ) {
	// String propName = prop.getAsString( Key._name );

	// Element theNode = this.document.createElement( "generator" );
	// String generatorType = inspector.getPropertyAnnotation( prop, ORMKeys.generator );
	// theNode.setAttribute( "class", generatorType );
	// IStruct params = new Struct();

	// // generator=foreign
	// if ( inspector.hasPropertyAnnotation( prop, ORMKeys.property ) ) {
	// params.put( "property", inspector.getPropertyAnnotation( prop, ORMKeys.property ) );
	// }
	// // generator=select
	// if ( inspector.hasPropertyAnnotation( prop, ORMKeys.selectKey ) ) {
	// params.put( "key", inspector.getPropertyAnnotation( prop, ORMKeys.selectKey ) );
	// }
	// if ( inspector.hasPropertyAnnotation( prop, ORMKeys.generated ) ) {
	// params.put( "generated", inspector.getPropertyAnnotation( prop, ORMKeys.generated ) );
	// }
	// // generator=sequence|sequence-identity
	// if ( inspector.hasPropertyAnnotation( prop, ORMKeys.sequence ) ) {
	// params.put( "sequence", inspector.getPropertyAnnotation( prop, ORMKeys.sequence ) );
	// }
	// if ( inspector.hasPropertyAnnotation( prop, Key.params ) ) {
	// Object paramValue = prop.getAsStruct( Key.annotations ).getAsString( Key.params );
	// IStruct additionalParams = Struct.fromMap( ( Map ) JSONUtil.fromJSON( paramValue ) );
	// if ( params == null ) {
	// logger.warn( "Property '{}' has a 'params' annotation that could not be cast to a struct: {}", propName, paramValue );
	// return theNode;
	// } else {
	// params.putAll( additionalParams );
	// }
	// }
	// params.forEach( ( key, value ) -> {
	// Element paramEl = this.document.createElement( "param" );
	// paramEl.setAttribute( "name", key.getName() );
	// paramEl.setTextContent( value.toString() );
	// theNode.appendChild( paramEl );
	// } );
	// return theNode;
	// }

	/**
	 * Generate the top-level &lt;class /&gt; element containing entity mapping metadata.
	 * 
	 * @return A &lt;class /&gt; element containing entity keys, properties, and other Hibernate mapping metadata.
	 */
	public Element generateClassElement() {
		Element classElement = this.document.createElement( "class" );

		// general class attributes:
		if ( entity.getEntityName() != null && !entity.getEntityName().isEmpty() ) {
			classElement.setAttribute( "entity-name", entity.getEntityName() );
		}
		if ( entity.isDynamicInsert() ) {
			classElement.setAttribute( "dynamic-insert", "true" );
		}
		if ( entity.isDynamicUpdate() ) {
			classElement.setAttribute( "dynamic-update", "true" );
		}
		if ( entity.getBatchSize() != null ) {
			classElement.setAttribute( "batch-size", StringCaster.cast( entity.getBatchSize() ) );
		}
		if ( entity.isLazy() ) {
			classElement.setAttribute( "lazy", "true" );
		}
		if ( entity.isSelectBeforeUpdate() ) {
			classElement.setAttribute( "rowid", "true" );
		}
		if ( entity.getOptimisticLock() != null ) {
			classElement.setAttribute( "optimistic-lock", entity.getOptimisticLock() );
		}
		if ( entity.isImmutable() ) {
			classElement.setAttribute( "mutable", "false" );
		}
		if ( entity.getRowID() != null ) {
			classElement.setAttribute( "rowid", entity.getRowID() );
		}
		if ( entity.getWhere() != null ) {
			classElement.setAttribute( "where", entity.getWhere() );
		}

		// And, if no discriminator or joinColumn is present:
		if ( entity.isSimpleEntity() ) {
			String tableName = entity.getTableName();
			if ( tableName != null ) {
				classElement.setAttribute( "table", tableName );
			}
			if ( entity.getSchema() != null ) {
				classElement.setAttribute( "schema", entity.getSchema() );
			}
			if ( entity.getCatalog() != null ) {
				classElement.setAttribute( "catalog", entity.getCatalog() );
			}
		}

		// generate keys, aka <id> elements
		entity.getIdProperties().stream().forEach( ( propertyMeta ) ->

		{
			classElement.appendChild( generateIdElement( propertyMeta ) );
		} );

		// generate properties, aka <property> elements
		entity.getProperties().stream().forEach( ( propertyMeta ) -> {
			classElement.appendChild( generatePropertyElement( propertyMeta ) );
		} );

		addDiscriminatorData( classElement, entity.getDiscriminator() );
		// @TODO: generate <subclass> elements
		// @TODO: generate <joined-subclass> elements
		// @TODO: generate <union-subclass> elements
		// @TODO: generate <version>
		// @TODO: generate <many-to-one>
		// @TODO: generate <one-to-one>
		// @TODO: generate <version>

		return classElement;
	}

}
